# JVM和内存管理面试题

## 1. JVM基础

### 题目1：JVM的内存结构是什么？

**答案：**
JVM内存主要分为以下几个区域：

**线程共享区域：**
- **堆（Heap）**：存储对象实例和数组
  - 新生代（Young Generation）：Eden、Survivor0、Survivor1
  - 老年代（Old Generation）
- **方法区（Method Area）**：存储类信息、常量、静态变量
  - 元空间（Metaspace，JDK 8+）替代永久代

**线程私有区域：**
- **程序计数器（PC Register）**：记录执行指令地址
- **虚拟机栈（VM Stack）**：存储局部变量、操作栈
- **本地方法栈（Native Method Stack）**：为native方法服务

**直接内存（Direct Memory）**：不属于JVM内存，但被JVM使用

### 题目2：新生代和老年代的垃圾回收有什么区别？

**答案：**

**新生代GC（Minor GC）：**
- **频率**：频繁
- **算法**：复制算法
- **触发**：Eden区满时
- **速度**：快
- **存活对象**：少量长期存活对象晋升到老年代

**老年代GC（Major GC）：**
- **频率**：较少
- **算法**：标记-清除或标记-整理
- **触发**：老年代空间不足
- **速度**：慢
- **影响**：可能引起Full GC

**代码示例见：** `JVMMemoryExample.java`

## 2. 垃圾回收

### 题目3：垃圾回收的算法有哪些？

**答案：**

1. **标记-清除（Mark-Sweep）**
   - **过程**：标记垃圾对象，然后清除
   - **优点**：不需要移动对象
   - **缺点**：产生内存碎片

2. **复制算法（Copying）**
   - **过程**：将存活对象复制到另一块内存
   - **优点**：没有内存碎片，实现简单
   - **缺点**：需要额外内存空间

3. **标记-整理（Mark-Compact）**
   - **过程**：标记后将存活对象向一端移动
   - **优点**：没有内存碎片，不需要额外空间
   - **缺点**：需要移动对象，成本较高

4. **分代收集**
   - **新生代**：使用复制算法
   - **老年代**：使用标记-清除或标记-整理

### 题目4：常见的垃圾收集器有哪些？

**答案：**

**Serial收集器：**
- 单线程收集器
- 适用于客户端模式
- 收集时暂停所有用户线程

**Parallel收集器：**
- 多线程收集器
- 注重吞吐量
- 适用于后台计算任务

**CMS收集器：**
- 并发标记清除
- 注重响应时间
- 老年代收集器

**G1收集器：**
- 面向服务端应用
- 低延迟目标
- 整堆收集器

### 题目5：什么情况下会发生内存泄漏？

**答案：**
1. **静态集合持有对象引用**
2. **监听器未及时移除**
3. **内部类持有外部类引用**
4. **ThreadLocal未清理**
5. **数据库连接、IO流未关闭**

**代码示例见：** `MemoryLeakExample.java`

## 3. JVM参数调优

### 题目6：常用的JVM参数有哪些？

**答案：**

**内存相关：**
- `-Xms`：初始堆大小
- `-Xmx`：最大堆大小
- `-Xmn`：新生代大小
- `-XX:NewRatio`：老年代/新生代比例
- `-XX:SurvivorRatio`：Eden/Survivor比例

**GC相关：**
- `-XX:+UseG1GC`：使用G1收集器
- `-XX:+UseConcMarkSweepGC`：使用CMS收集器
- `-XX:+UseParallelGC`：使用Parallel收集器
- `-XX:MaxGCPauseMillis`：最大GC停顿时间

**调试相关：**
- `-XX:+PrintGC`：打印GC信息
- `-XX:+HeapDumpOnOutOfMemoryError`：OOM时生成堆转储

### 题目7：如何分析GC日志？

**答案：**
GC日志包含以下信息：
- **GC类型**：Minor GC、Major GC、Full GC
- **回收前后内存使用情况**
- **GC耗时**
- **回收效果**

**分析工具：**
- GCViewer
- GCEasy
- VisualVM

## 4. 类加载机制

### 题目8：类加载的过程是什么？

**答案：**
类加载包括以下几个阶段：

1. **加载（Loading）**
   - 读取.class文件
   - 在内存中生成Class对象

2. **验证（Verification）**
   - 文件格式验证
   - 元数据验证
   - 字节码验证
   - 符号引用验证

3. **准备（Preparation）**
   - 为静态变量分配内存
   - 设置默认初始值

4. **解析（Resolution）**
   - 符号引用转换为直接引用

5. **初始化（Initialization）**
   - 执行类构造器<clinit>()方法

### 题目9：类加载器的双亲委派模型？

**答案：**
**类加载器层次：**
- **启动类加载器（Bootstrap ClassLoader）**
- **扩展类加载器（Extension ClassLoader）**
- **应用程序类加载器（Application ClassLoader）**
- **自定义类加载器**

**双亲委派过程：**
1. 收到类加载请求
2. 委派给父类加载器
3. 父类加载器无法加载时，子类加载器才尝试加载

**优点：**
- 避免类的重复加载
- 保证核心类库的安全性

**代码示例见：** `ClassLoaderExample.java`

## 5. 性能调优

### 题目10：如何进行JVM性能调优？

**答案：**

**调优步骤：**
1. **监控和诊断**
   - 使用工具监控应用性能
   - 分析GC日志和堆转储

2. **确定调优目标**
   - 吞吐量优先还是延迟优先
   - 设定具体的性能指标

3. **参数调整**
   - 堆大小设置
   - GC算法选择
   - 新生代/老年代比例调整

4. **验证效果**
   - 压力测试
   - 性能对比

**常见工具：**
- JVisualVM
- JProfiler
- Eclipse MAT
- JConsole

### 题目11：内存溢出的类型和解决方案？

**答案：**

**OutOfMemoryError类型：**

1. **Java heap space**
   - **原因**：堆内存不足
   - **解决**：增加-Xmx参数，检查内存泄漏

2. **Metaspace**
   - **原因**：元空间不足
   - **解决**：增加-XX:MetaspaceSize参数

3. **Direct buffer memory**
   - **原因**：直接内存不足
   - **解决**：增加-XX:MaxDirectMemorySize参数

4. **unable to create new native thread**
   - **原因**：无法创建新线程
   - **解决**：减少线程数量或增加系统限制

**代码示例见：** `OutOfMemoryExample.java`

## 6. JVM监控

### 题目12：如何监控JVM运行状态？

**答案：**

**命令行工具：**
- **jps**：列出Java进程
- **jstat**：GC和内存统计
- **jmap**：生成堆转储
- **jstack**：生成线程转储
- **jinfo**：查看JVM参数

**图形化工具：**
- **JVisualVM**：全功能监控工具
- **JConsole**：JMX监控工具
- **Eclipse MAT**：内存分析工具

**第三方工具：**
- **Arthas**：阿里巴巴开源诊断工具
- **JProfiler**：商业性能分析工具

### 题目13：如何分析线程死锁？

**答案：**
**检测方法：**
1. **jstack命令**：生成线程转储文件
2. **JVisualVM**：图形化死锁检测
3. **程序中使用ThreadMXBean**

**分析步骤：**
1. 查找死锁线程
2. 分析锁的持有和等待关系
3. 确定循环等待的资源
4. 修改代码避免死锁

**代码示例见：** `DeadlockDetectionExample.java`